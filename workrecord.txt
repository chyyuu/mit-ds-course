lecture 1
听了Robert Morris的6.824第一堂课，不用ppt，没有教材，拿着两页纸开讲，强调实践。佩服！

lecture2
先讲了RPC，以及at-least-once的缺点，at-most-once的好处，然后讲thread，以golang为例，介绍了golang中的goroutine, channel, sync.Mutex的情况。期间学生提了不少问题，课题气氛比较活跃。课程中花了近 40 mins的时间用在golang上，结合看golang的代码，确实比clang简洁不少。


2/5/2013~2/9/2013
lab1 hand out in Tue
Tue~Fri: learn golang
Fri~Sat: finish lab1


The design idea is important, also should understand the goloang program. At first I made a mistake that let every lock contain a request seq num, and seq num is increased . In fact, the client should contian a request seq num, and the seq num could be rand (more easy to implementation)



key:
0 notice at-most-once mechanism in RPC process. and only kill Pri or Bak srv (only one , but not two all), and the killed pri srv can not handle the request. Dying pri srv could handle rqueest but not reply info to client.
1 define xid(unique id) for client's request's seq number
2 server should store the used(or seen) request(with unique id) and related reply result, then it can decide if the request(xid) has been handled before?
3 Pri srv does the same thing as that of Bak srv. But when Pri srv finish the handling, it have to diliver a rpc call to Bak srv to ask Bak srv handle the same request from client. 

